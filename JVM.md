# JVM

## 1、JVM的简介

VM 是 Java Virtual Machine 的缩写，它是一个虚构出来的计算机，一种规范。通过在实际的计算机上仿真模拟各类计算机功能实现···

好，其实抛开这么专业的句子不说，就知道JVM其实就类似于一台小电脑运行在windows或者linux这些操作系统环境下即可。它直接和操作系统进行交互，与硬件不直接交互，而操作系统可以帮我们完成和硬件进行交互的工作。

 ![](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/d947f91e44c44c6c80222b49c2dee859-new-image19a36451-d673-486e-9c8e-3c7d8ab66929.png)

## 2、JVM、JRE、JDK

### 2.1、什么是JRE？

JRE（Java运行时环境）是一个软件包，提供Java类库，Java虚拟机（JVM）和运行Java应用程序所需的其他组件。JRE是JVM的超集。

### 2.2、什么是JDK

JDK（Java开发工具包）是使用Java开发应用程序所需的软件开发工具包。当您下载JDK时，还将同时下载JRE。除了JRE，JDK还包含许多开发工具（编译器，JavaDoc，Java Debugger等）。

## 3、JVM体系结构

![](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/1c1d85b5fb8b47239af2a5c0436eb2d7-new-image0cd10827-2f96-433c-9b16-93d4fe491d88.png)



#### ① 类加载器

如果 **JVM** 想要执行这个 **.class** 文件，我们需要将其装进一个 **类加载器** 中，它就像一个搬运工一样，会把所有的 **.class** 文件全部搬进JVM里面来。

#### ② 方法区

**方法区** 是用于存放类似于元数据信息方面的数据的，比如**类信息，常量，静态变量，编译后代码**···等

类加载器将 .class 文件搬过来就是先丢到这一块上

#### ③ 堆

**堆** 主要放了一些存储的数据，比如对象实例，数组···等，它和方法区都同属于 **线程共享区域** 。也就是说它们都是 **线程不安全** 的

#### ④ 栈

**栈** 这是我们的代码运行空间。我们编写的每一个方法都会放到 **栈** 里面运行。

我们会听说过 本地方法栈 或者 本地方法接口 这两个名词，不过我们基本不会涉及这两块的内容，它俩底层是使用C来进行工作的，和Java没有太大的关系。

#### ⑤ 程序计数器

主要就是完成一个加载工作，类似于一个指针一样的，指向下一行我们需要执行的代码。和栈一样，都是 **线程独享** 的，就是说每一个线程都会有自己对应的一块区域而不会存在并发和多线程的问题。

## 4、类加载器

从类被加载到虚拟机内存中开始，到释放内存总共有7个步骤：加载，验证，准备，解析，初始化，使用，卸载。其中**验证，准备，解析三个部分统称为连接**

**加载、连接、初始化、使用、卸载**

### 4.1 类加载器的加载顺序 8

加载一个Class类的顺序也是有优先级的，类加载器从最底层开始往上的顺序是这样的

1. **BootStrap ClassLoader**：rt.jar
2. **Extension ClassLoader**: 加载扩展的jar包
3. **App ClassLoader**：指定的classpath下面的jar包
4. Custom ClassLoader：自定义的类加载器

### 4.2 双亲委派机制

当一个类收到了加载请求时，它是不会先自己去尝试加载的，而是**委派给父类去**完成，比如我现在要 new 一个 Person，这个 Person 是我们自定义的类，如果我们要加载它，就会先委派 App ClassLoader ，只有**当父类加载器都反馈自己无法完成这个请求**（也就是父类加载器都没有找到加载所需的 Class）时，子类加载器才会自行尝试加载。

这样做的好处是，加载位于 rt.jar 包中的类时不管是哪个加载器加载，**最终都会委托到 BootStrap ClassLoader 进行加载**，这样保证了使用不同的类加载器得到的都是同一个结果。

## 5、运行时数据区

### 5.1、本地方法栈（Native Method Stack）

Thread类的源码，会看到它的start0方法带有一个**native关键字修饰**，而且不存在方法体，这种用native修饰的方法就是本地方法，这是使**用C来实**现的，然后一般这些方法都会放到一个叫做**本地方法栈的区域**。

![image-20220830191027356](../图片/image-20220830191027356.jpeg)

**程序计数器**其实就是一个**指针**，它指向了我们程序中下一句需要执行的指令，它也是内存区域中唯一一个不会出现OutOfMemoryError的区域，而且占用内存空间小到基本可以忽略不计。这个内存仅代表当前线程所执行的字节码的行号指示器，字节码解析器通过改变这个计数器的值选取下一条需要执行的字节码指令。

如果执行的是native方法，那这个指针就不工作了。

### 5.2、堆

JVM内存会划分为堆内存和非堆内存，堆内存中也会划分为**年轻代**和**老年代**，而非堆内存则为**永久代**。

在1.8中已经移除永久代，替代品是一个**元空间**(MetaSpace)。metaSpace是不存在于JVM中的，它使用的是本地内存。

```java
MetaspaceSize：初始化元空间大小，控制发生GC
MaxMetaspaceSize：限制元空间大小上限，防止占用过多物理内存。
```

年轻代又会分为**Eden**和**Survivor**区。（伊甸园区和幸存区）

**Survivor**也会分为**FromPlace**和**ToPlace**

![image-20220831130853344](../图片/image-20220831130853344.jpeg)

当老年区执行了full gc之后仍然无法进行对象保存的操作，就会产生OOM，这时候就是虚拟机中的堆内存不足，原因可能会是**堆内存设置的大小**过小，这个可以**通过参数-Xms、-Xmx**来调整。

![image-20220831145004434](../图片/image-20220831145004434.jpeg)

```java
ackage com.jvm;

/**
 * @author jjm
 * @version 1.0
 */
public class Memory {
    public static void main(String[] args) {
        long a=Runtime.getRuntime().totalMemory();

        long b=Runtime.getRuntime().maxMemory();

        //-Xms1024m -Xmx1024m -XX:+PrintGCDetails
        System.out.println("totalMemory:"+a/1024/1024+"MB");
        System.out.println("maxMemory:"+b/1024/1024+"MB");
    }
}
```

### 5.3、垃圾回收

垃圾收集器所关注的都是**堆和方法区**这部分内存。

**判断对象需要被干掉**

1.**引用计数器计算**：给对象添加一个引用计数器，每次引用这个对象时计数器加一，引用失效时减一，计数器等于0时就是不会再次使用的。不过这个方法有一种情况就是出现对象的循环引用时GC没法回收。

2.**可达性分析计算**：这是一种类似于二叉树的实现，将一系列的GC ROOTS作为起始的存活对象集，从这个节点往下搜索，搜索所走过的路径成为引用链，把能被该集合引用到的对象加入到集合中。搜索当一个对象到GC Roots（二次标记，第二次如果被引用则移出）没有使用任何引用链时，则说明该对象是不可用的。主流的商用程序语言，例如Java，C#等都是靠这招去判定对象是否存活的。



**垃圾回收算法**

复制算法

![image-20220831154107708](../图片/image-20220831154107708.jpeg)

标记清除算法

![image-20220831154137679](../图片/image-20220831154137679.jpeg)

标记整理算法

![image-20220831154201208](../图片/image-20220831154201208.jpeg)

内存效率：复制算法 >标记清除算法> 标记整理算法

内存利用率：标记整理算法> 标记清除算法> 复制算法

内存整齐度：标记整理算法=复制算法 >标记清除算法

#### 分代收集算法

这种算法并没有什么新的思想，只是根据对象存活周期的不同将内存划分为几块。一般是把Java堆分为**新生代和老年代**，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记-清理”或者“标记-整理”算法来进行回收。

